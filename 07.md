## Chapter 7.

### Exercise 7.01

Show how the list comprehension `[f x | x <- xs, p x]` can be re-expressed using
the higher-order functions `map` and `filter`.

### Solution

```haskell
map f (filter p xs)
```

### Exercise 7.02

Without looking at the definitions from the standard prelude, define the
following higher-order library functions on lists.

1. Decide if all elements of a list satisfy a predicate:

        all :: (a -> Bool) -> [Bool] -> Bool

2. Decide if any element of a list satisfies a predicate:

        any :: (a -> Bool) -> [Bool] -> Bool

3. Select elements from a list while they satisfy a predicate:

        takeWhile :: (a -> Bool) -> [a] -> [a]

4. Remove elements from a list while they satisfy a predicate:

        dropWhile :: (a -> Bool) -> [a] -> [a]

Note: in the prelude the first two of these functions are generic functions
rather than being specific to the type of lists.

### Solution

```haskell
all :: (a -> Bool) -> [Bool] -> Bool
all p = and . (map p)

any :: (a -> Bool) -> [Bool] -> Bool
any p = or . (map p)

takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ [] = []
takeWhile p (a:as)
    | p a       = a : takeWhile p as
    | otherwise = []

dropWhile :: (a -> Bool) -> [a] -> [a]
dropWhile _ [] = []
dropWhile p (a:as)
    | p a = dropWhile p as
    | otherwise = a:as
```

### Exercise 7.03

Redefine the functions `map f` and `filter p` using `foldr`.

### Solution

```haskell
map :: (a -> b) -> [a] -> [b]
map f = foldr (\x xs -> f x : xs) []

filter :: (a -> Bool) -> [a] -> [a]
filter p = foldr (\x xs -> if p x then x:xs else xs) []
```
